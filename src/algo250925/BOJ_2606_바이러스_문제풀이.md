# BOJ 2606번 바이러스 - 그래프 탐색 완전 정리

## 📋 문제 분석

**2606번 바이러스** 문제는 **그래프 탐색**의 기본 문제입니다.

**핵심 요구사항:**
- 1번 컴퓨터에서 시작해서 네트워크로 연결된 모든 컴퓨터를 찾기
- 간접적으로 연결된 컴퓨터들도 포함 (1→2→3처럼)
- 1번 컴퓨터 자신은 제외하고 감염되는 컴퓨터 수만 세기

## 🌐 그래프 이론 기본 개념

### 그래프(Graph)란?
- **노드(정점, Vertex)**: 컴퓨터들 (1, 2, 3, 4, 5, 6, 7)
- **엣지(간선, Edge)**: 컴퓨터 간 연결 관계
- **무방향 그래프**: 양방향 연결 (1↔2)

### 그래프 표현 방법
```java
// 인접 리스트 - 메모리 효율적
ArrayList<Integer>[] graph = new ArrayList[n+1];

// 인접 행렬 - 구현 간단하지만 메모리 많이 씀
boolean[][] graph = new boolean[n+1][n+1];
```

## 🔍 탐색 알고리즘

### **BFS (너비 우선 탐색)**
- **특징**: 가까운 노드부터 차례로 방문
- **구조**: 큐(Queue) 사용
- **과정**: 시작점 → 1단계 이웃들 → 2단계 이웃들...

### **DFS (깊이 우선 탐색)**
- **특징**: 한 방향으로 끝까지 가본 후 되돌아가기
- **구조**: 스택(Stack) 또는 재귀 사용
- **과정**: 시작점 → 깊숙이 들어가기 → 막다른 길 → 뒤로가서 다른 길

## 💡 문제 해결 접근법

1. **그래프 구성**: 컴퓨터 연결 관계를 인접 리스트로 저장
2. **탐색 실행**: 1번에서 시작해 연결된 모든 노드 방문
3. **방문 체크**: 이미 방문한 노드는 다시 방문하지 않음
4. **결과 계산**: 방문한 노드 수 - 1 (1번 제외)

## 🚀 Java 풀이 구현

### 방법 1: BFS (너비 우선 탐색)

```java
import java.io.*;
import java.util.*;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        int n = Integer.parseInt(br.readLine());
        int m = Integer.parseInt(br.readLine());

        // 그래프 생성 (인접 리스트)
        ArrayList<Integer>[] graph = new ArrayList[n + 1];
        for (int i = 1; i <= n; i++) {
            graph[i] = new ArrayList<>();
        }

        // 간선 정보 입력
        for (int i = 0; i < m; i++) {
            StringTokenizer st = new StringTokenizer(br.readLine());
            int a = Integer.parseInt(st.nextToken());
            int b = Integer.parseInt(st.nextToken());
            graph[a].add(b);
            graph[b].add(a);
        }

        // BFS 실행
        boolean[] visited = new boolean[n + 1];
        Queue<Integer> queue = new LinkedList<>();

        queue.offer(1);
        visited[1] = true;
        int count = 0;

        while (!queue.isEmpty()) {
            int current = queue.poll();

            for (int neighbor : graph[current]) {
                if (!visited[neighbor]) {
                    visited[neighbor] = true;
                    queue.offer(neighbor);
                    count++;
                }
            }
        }

        System.out.println(count);
    }
}
```

### 방법 2: DFS (깊이 우선 탐색)

```java
import java.io.*;
import java.util.*;

public class Main {
    static ArrayList<Integer>[] graph;
    static boolean[] visited;
    static int count = 0;

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        int n = Integer.parseInt(br.readLine());
        int m = Integer.parseInt(br.readLine());

        // 그래프 생성
        graph = new ArrayList[n + 1];
        visited = new boolean[n + 1];

        for (int i = 1; i <= n; i++) {
            graph[i] = new ArrayList<>();
        }

        // 간선 정보 입력
        for (int i = 0; i < m; i++) {
            StringTokenizer st = new StringTokenizer(br.readLine());
            int a = Integer.parseInt(st.nextToken());
            int b = Integer.parseInt(st.nextToken());
            graph[a].add(b);
            graph[b].add(a);
        }

        // DFS 실행 (1번 노드 방문 처리 후 시작)
        visited[1] = true;
        dfs(1);

        System.out.println(count);
    }

    static void dfs(int node) {
        for (int neighbor : graph[node]) {
            if (!visited[neighbor]) {
                visited[neighbor] = true;
                count++;
                dfs(neighbor);
            }
        }
    }
}
```

## 📖 코드 상세 설명

### BFS 동작 과정 (예제 기준)
```
초기: Queue=[1], visited=[1]
1단계: 1에서 연결된 2,5 발견 → Queue=[2,5], count=2
2단계: 2에서 연결된 3 발견 → Queue=[5,3], count=3
3단계: 5에서 연결된 6 발견 → Queue=[3,6], count=4
4단계: 3,6 처리 완료 → 최종 count=4
```

### 핵심 구현 포인트

**1. 그래프 표현**
```java
ArrayList<Integer>[] graph = new ArrayList[n + 1];  // 인덱스 1부터 사용
graph[a].add(b);  // 양방향 연결
graph[b].add(a);
```

**2. 방문 체크**
```java
boolean[] visited = new boolean[n + 1];  // 중복 방문 방지
if (!visited[neighbor]) { ... }  // 미방문 노드만 처리
```

**3. BFS vs DFS 차이점**
- **BFS**: 큐 사용, 레벨 순서로 탐색
- **DFS**: 재귀/스택 사용, 깊이 우선 탐색

## 🎯 학습 가이드

### 단계별 학습 로드맵

**1단계: 기본 개념 이해**
- 그래프 자료구조 개념
- 인접 리스트 vs 인접 행렬
- BFS/DFS 알고리즘 원리

**2단계: 구현 연습**
- 간단한 그래프 탐색 구현
- 방문 체크 로직 숙달
- 큐/스택 자료구조 활용

**3단계: 문제 적용**
- 연결 요소 찾기
- 최단 경로 (BFS)
- 사이클 탐지 (DFS)

### 추천 연습 문제
- **2667번**: 단지번호붙이기 (연결 요소)
- **1260번**: DFS와 BFS (기본 탐색)
- **7576번**: 토마토 (BFS 응용)

### 디버깅 팁
1. **그래프 출력**: 입력이 제대로 들어왔는지 확인
2. **방문 배열**: 각 단계별 방문 상태 출력
3. **큐/스택 상태**: 탐색 과정 추적

## 🔥 마무리

그래프 이론이 처음이라면 **BFS 풀이**부터 시작하는 것을 추천합니다. 큐의 동작 과정이 직관적이고, 디버깅도 쉽기 때문입니다.

두 코드 모두 동일한 결과를 출력하니, 편한 방법으로 연습해보세요!