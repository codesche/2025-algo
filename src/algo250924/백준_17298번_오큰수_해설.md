# 백준 17298번: 오큰수 문제 해설

## 문제 개요
- **문제 번호**: 17298번
- **문제명**: 오큰수
- **난이도**: 골드 IV
- **링크**: https://www.acmicpc.net/problem/17298

## 문제 설명
크기가 N인 수열 A = A₁, A₂, ..., Aₙ이 있을 때, 각 원소 Aᵢ에 대해서 오큰수 NGE(i)를 구하는 문제입니다.

- **오큰수**: Aᵢ의 오른쪽에 있으면서 Aᵢ보다 큰 수 중에서 가장 왼쪽에 있는 수
- 그러한 수가 없는 경우 오큰수는 -1

### 예시
- A = [3, 5, 2, 7] → NGE = [5, 7, 7, -1]
- A = [9, 5, 4, 8] → NGE = [-1, 8, 8, -1]

### 제약조건
- 1 ≤ N ≤ 1,000,000
- 1 ≤ Aᵢ ≤ 1,000,000

## 해결 방법

### 핵심 아이디어: 스택(Stack) 활용
**스택을 이용한 O(N) 알고리즘**으로 효율적으로 해결할 수 있습니다.

### 알고리즘 원리
1. **스택에 인덱스 저장**: 아직 오큰수를 찾지 못한 원소들의 인덱스를 스택에 보관
2. **단조성 유지**: 스택 bottom → top 순서로 해당 인덱스의 값들이 내림차순이 되도록 유지
3. **즉시 처리**: 새 원소가 스택의 원소들보다 클 때 해당 원소들의 오큰수로 설정

### 알고리즘 과정
```
배열을 왼쪽부터 순회하며:
1. 현재 원소가 스택 top의 원소보다 크면
   → 스택에서 pop하고 그 위치의 오큰수를 현재 원소로 설정
   → 현재 원소보다 작은 원소들이 모두 나올 때까지 반복
2. 현재 인덱스를 스택에 push
```

### 동작 과정 예시 (A = [3, 5, 2, 7])
1. i=0, A[0]=3: 스택=[] → 0 추가 → 스택=[0]
2. i=1, A[1]=5: A[1] > A[0] → 0을 pop하고 NGE[0]=5, 1 추가 → 스택=[1]
3. i=2, A[2]=2: A[2] < A[1] → 2 추가 → 스택=[1,2]
4. i=3, A[3]=7: A[3] > A[2] → 2를 pop하고 NGE[2]=7, A[3] > A[1] → 1을 pop하고 NGE[1]=7, 3 추가 → 스택=[3]

**결과**: NGE = [5, 7, 7, -1]

## 코드 구현

```java
import java.io.*;
import java.util.*;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

        int n = Integer.parseInt(br.readLine());
        int[] arr = new int[n];
        int[] result = new int[n];
        Stack<Integer> stack = new Stack<>();

        StringTokenizer st = new StringTokenizer(br.readLine());
        for (int i = 0; i < n; i++) {
            arr[i] = Integer.parseInt(st.nextToken());
            result[i] = -1; // 초기값을 -1로 설정
        }

        for (int i = 0; i < n; i++) {
            // 현재 원소가 스택 top의 원소보다 클 때까지 pop
            while (!stack.isEmpty() && arr[stack.peek()] < arr[i]) {
                result[stack.pop()] = arr[i];
            }
            stack.push(i);
        }

        // 결과 출력
        for (int i = 0; i < n; i++) {
            bw.write(result[i] + " ");
        }

        br.close();
        bw.close();
    }
}
```

## 시간복잡도 분석
- **시간복잡도**: O(N)
  - 각 원소는 스택에 최대 한 번 들어가고 최대 한 번 나옴
- **공간복잡도**: O(N)
  - 스택과 결과 배열을 위한 공간

## 핵심 포인트
1. **스택을 이용한 단조성 유지**: 아직 오큰수를 찾지 못한 원소들의 인덱스만 스택에 보관
2. **즉시 처리 방식**: 새 원소가 기존 원소들의 오큰수가 될 수 있다면 즉시 처리
3. **O(N) 효율성**: 각 원소는 스택에 한 번만 들어가고 한 번만 나와서 선형 시간에 해결
4. **Java 구현 시 주의사항**:
   - `BufferedReader/BufferedWriter` 사용으로 빠른 입출력
   - `Stack<Integer>`로 인덱스 저장
   - `StringTokenizer`로 효율적인 파싱

이 알고리즘을 통해 N ≤ 1,000,000 제약조건을 효율적으로 처리할 수 있습니다.