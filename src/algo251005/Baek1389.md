
## 전체 알고리즘 개요

1. 입력으로 무방향 그래프(인접 리스트)를 만든다.
2. 각 정점 s(1..N)에 대해 BFS를 돌려 dist[s→v]를 구하고, 그 합을 sum에 누적한다.
3. sum이 현재 최소보다 작으면 answer = s로 갱신한다.

```java
for (int s = 1; s <= N; s++) {
    int sum = bfsSum(s);
    if (sum < bestSum) { // 동점 미갱신 → 자연스러운 '번호 작은 사람' 우선
        bestSum = sum;
        answer = s;
    }
}
```
동점인 경우 미갱신 -> 자연스럽게 '번호 작은 사람' 우선

4. BFS로 최단거리 합 구하기
```java

static int bfsSum(int s) {
    int[] dist = new int[N + 1];
    Arrays.fill(dist, -1);      // 방문 겸 최단거리 저장 (-1 = 미방문)
    ArrayDeque<Integer> queue = new ArrayDeque<>();

    dist[s] = 0;
    queue.add(s);

    while (!q.isEmpty()) {
        int cur = queue.pollFirst();
        for (int next : graph[cur]) {
            if (dist[next] != -1) continue;   // 이미 최단거리 확정
            dist[next] = dist[cur] + 1;       // 가중치 1 → 한 칸 증가
            queue.addLast(next);
        }
    }

    int sum = 0;
    for (int i = 1; i <= N; i++) {
        if (dist[i] == -1) return Integer.MAX_VALUE / 2; // (안전장치) 도달 불가 시 큰 값
        sum += dist[i];
    }
    return sum;
}
```